package services

import (
	"fmt"
	"os"
	"reflect"
	"strconv"

	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/aws/session"
	"github.com/guregu/dynamo"
)

type dynamoService struct {
	tableName string
	hashName  string
	rangeName string
	composite bool
}

type operation int

const (
	dynamoServicePut = iota
	dynamoServiceGet
	dynamoServiceDelete
	dynamoServiceScan
	dynamoServiceQuery
)

func (d dynamoService) connect() *dynamo.DB {
	sess := session.New()
	conf := &aws.Config{}
	if local, err := strconv.ParseBool(os.Getenv("LOCAL")); err == nil && local {
		conf.Endpoint = aws.String(os.Getenv("ENDPOINT"))
		conf.Region = aws.String(os.Getenv("REGION"))
	}

	return dynamo.New(sess, conf)
}

func (d dynamoService) getProjection(selects map[string]interface{}) []string {
	proj := []string{}
	for k := range selects {
		proj = append(proj, "'"+k+"'")
	}

	return proj
}

func batch(in interface{}, batchSize int) ([][]interface{}, error) {
	t := reflect.TypeOf(in)
	switch t.Kind() {
	case reflect.Slice:
		s := reflect.ValueOf(in)
		// duplicate initial slice
		sd := make([]interface{}, s.Len())
		for i := 0; i < s.Len(); i++ {
			sd[i] = s.Index(i).Interface()
		}

		out := [][]interface{}{}
		for batchSize < len(sd) {
			sd, out = sd[batchSize:], append(out, sd[0:batchSize:batchSize])
		}
		out = append(out, sd)

		return out, nil
	default:
		return nil, fmt.Errorf("Input must be a Slice")
	}

}

// Put writes the given Model to DynamoDB
func (d dynamoService) Put(in interface{}) error {
	return d.connect().Table(d.tableName).Put(in).Run()
}

// BatchWrite writes a Slice of Models to DynamoDB
func (d dynamoService) BatchWrite(in interface{}, batchSize int) error {
	keys := []string{d.hashName}
	if d.composite {
		keys = append(keys, d.rangeName)
	}

	bs, err := batch(in, batchSize)
	if err != nil {
		return err
	}

	w := d.connect().Table(d.tableName).Batch(keys...).Write()
	for _, b := range bs {
		_, err = w.Put(b...).Run()
		if err != nil {
			return err
		}
	}

	return nil
}

// Get retrieves the Model with the given Key Map from DynamoDB
func (d dynamoService) Get(out interface{}, selects map[string]interface{}, keys ...interface{}) error {
	if len(keys) > 2 {
		return fmt.Errorf("Too many Keys provided")
	}
	q := d.connect().Table(d.tableName).Get(d.hashName, keys[0])
	if d.composite {
		q.Range(d.rangeName, dynamo.Equal, keys[1])
	}
	if p := d.getProjection(selects); len(p) > 0 {
		q.Project(p...)
	}
	return q.One(out)
}

// Scan retrieves a List of all Models
func (d dynamoService) Scan(out interface{}, selects map[string]interface{}) error {
	s := d.connect().Table(d.tableName).Scan()
	if p := d.getProjection(selects); len(p) > 0 {
		s.Project(p...)
	}

	return s.All(out)
}

// Delete deletes the Model with the given Key Map from DynamoDB
func (d dynamoService) Delete(keys ...interface{}) error {
	if len(keys) > 2 {
		return fmt.Errorf("Too many Keys provided")
	}
	del := d.connect().Table(d.tableName).Delete(d.hashName, keys[0])
	if d.composite {
		del.Range(d.rangeName, keys[1])
	}
	return del.Run()
}
