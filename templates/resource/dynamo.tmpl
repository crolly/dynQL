package services

import (
	"errors"
	"fmt"
	"os"
	"strconv"

	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/aws/session"
	"github.com/guregu/dynamo"
)

type dynamoService struct {
	tableName string
	hashName  string
	rangeName string
	composite bool
}

type operation int

const (
	dynamoServicePut = iota
	dynamoServiceGet
	dynamoServiceDelete
	dynamoServiceScan
	dynamoServiceQuery
)

func (d dynamoService) connect() *dynamo.DB {
	sess := session.New()
	conf := &aws.Config{}
	if local, err := strconv.ParseBool(os.Getenv("LOCAL")); err == nil && local {
		conf.Endpoint = aws.String(os.Getenv("ENDPOINT"))
		conf.Region = aws.String(os.Getenv("REGION"))
	}

	return dynamo.New(sess, conf)
}

func (d dynamoService) runWithHash(hashValue interface{}, op operation, i interface{}, selects map[string]interface{}) error {
	switch op {
	case dynamoServiceGet:
		q := d.connect().Table(d.tableName).Get(d.hashName, hashValue)
		if p := d.getProjection(selects); len(p) > 0 {
			q.Project(p...)
		}
		return q.One(i)
	case dynamoServiceDelete:
		return d.connect().Table(d.tableName).Delete(d.hashName, hashValue).Run()
	}

	return nil
}

func (d dynamoService) runWithRange(hashValue, rangeValue interface{}, op operation, i interface{}, selects map[string]interface{}) error {
	switch op {
	case dynamoServiceGet:
		q := d.connect().Table(d.tableName).Get(d.hashName, hashValue).Range(d.rangeName, dynamo.Equal, rangeValue)
		if p := d.getProjection(selects); len(p) > 0 {
			q.Project(p...)
		}
		return q.One(i)
	case dynamoServiceDelete:
		return d.connect().Table(d.tableName).Delete(d.hashName, hashValue).Range(d.rangeName, rangeValue).Run()
	}

	return nil
}

func (d dynamoService) getHashKey(keys map[string]interface{}) (interface{}, error) {
	l := len(keys)
	if l != 1 {
		return "", fmt.Errorf("Invalid amount of keys. Expected: 1 - Actual: %d", l)
	}

	hashKey, ok := keys[d.hashName]
	if !ok {
		return "", errors.New("Wrong Name provided for the hashKey in Keys Map")
	}
	return hashKey, nil
}

func (d dynamoService) getCompositeKey(keys map[string]interface{}) (interface{}, interface{}, error) {
	l := len(keys)
	if l != 2 {
		return "", "", fmt.Errorf("Invalid amount of keys. Expected: 2 - Actual: %d", l)
	}

	hashKey, hOk := keys[d.hashName]
	rangeKey, rOk := keys[d.rangeName]
	if !hOk || !rOk {
		return "", "", errors.New("Wrong Name provided for the hashKey in Keys Map")
	}
	return hashKey, rangeKey, nil
}

func (d dynamoService) getProjection(selects map[string]interface{}) []string {
	proj := []string{}
	for k := range selects {
		proj = append(proj, "'"+k+"'")
	}

	return proj
}

// Put writes the given Model to DynamoDB
func (d dynamoService) Put(in interface{}) error {
	return d.connect().Table(d.tableName).Put(in).Run()
}

// Get retrieves the Model with the given Key Map from DynamoDB
func (d dynamoService) Get(keys map[string]interface{}, out interface{}, selects map[string]interface{}) error {
	if d.composite {
		hashKey, rangeKey, err := d.getCompositeKey(keys)
		if err != nil {
			return err
		}
		return d.runWithRange(hashKey, rangeKey, dynamoServiceGet, out, selects)
	}

	hashKey, err := d.getHashKey(keys)
	if err != nil {
		return err
	}
	return d.runWithHash(hashKey, dynamoServiceGet, out, selects)
}

// Scan retrieves a List of all Models
func (d dynamoService) Scan(out interface{}, selects map[string]interface{}) error {
	s := d.connect().Table(d.tableName).Scan()
	if p := d.getProjection(selects); len(p) > 0 {
		s.Project(p...)
	}

	return s.All(out)
}

// Delete deletes the Model with the given Key Map from DynamoDB
func (d dynamoService) Delete(keys map[string]interface{}) error {
	if d.composite {
		hashKey, rangeKey, err := d.getCompositeKey(keys)
		if err != nil {
			return err
		}
		return d.runWithRange(hashKey, rangeKey, dynamoServiceDelete, nil, nil)
	}

	hashKey, err := d.getHashKey(keys)
	if err != nil {
		return err
	}
	return d.runWithHash(hashKey, dynamoServiceDelete, nil, nil)
}
